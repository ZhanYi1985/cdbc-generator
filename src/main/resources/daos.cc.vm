#parse( "common.vm" )

#c_copyright()
/**
* @file
* all daos implements of $filename.
*
* NOTICE:
* This file is generated by tools.
* Please dont't modify this file.
* If u want to add more functions to
* daos. You can extends these classes,
* Not overwrites.
*/

\#include <stdlib.h>
\#include <string.h>
\#include <iostream>
\#include <string>
\#include <soci.h>
\#include <ctime>
\#include "$daoHeaderFile"
\#include "$secFile"

using namespace std;
using namespace soci;

namespace zt {
namespace db {

#foreach ($table in $tables)
	// class #_dao_name($table) implements begin.
	#_dao_name($table)::#_dao_name($table)(soci::session &_s)
		: _sql(_s)
	{

	}

	#_dao_name($table)::~#_dao_name($table)() {
	// Nothing.
	}

	bool #_dao_name($table)::insert( #_c_struct_name($table) *entity )
	{
#foreach ($column in $table.columns)
#if ($column.type == $DATETIME)
		std::tm $column.name;
    	localtime_r((time_t *)&entity->$column.name, &$column.name);
#else
		#_soci_field_type($column) $column.name = entity->$column.name;
#end
#end

    	const char *_sqlstr = " insert into $table.name ("
#foreach ($column in $table.columns)
## TODO: A bug here. When property autoIncrement of the last field is true.
#if ($column.autoIncrement == false)
#if ($velocityHasNext == true)
		" $column.name, "
#else
		" $column.name "
#end
#end
#end
		" ) values ( "
#foreach ($column in $table.columns)
## TODO: A bug here. When property autoIncrement of the last field is true.
#if ($column.autoIncrement == false)
#if ($velocityHasNext == true)
		" :$column.name, "
#else
		" :$column.name "
#end
#end
#end
		" ) ";
		_sql << _sqlstr,
#foreach ($column in $table.columns)
#if ($column.autoIncrement == false)
#if ($velocityHasNext == true)
		use($column.name),
#else
		use($column.name);
#end
#end
#end
		return true;
	}

#foreach ($index in $table.indexes)
	bool #_dao_name($table)::query_by_$index.name ( #_c_struct_name($table) *entity )
	{
#foreach ($column in $index.columns)
		#_soci_field_type($column) i_$column.name = entity->$column.name;
#end

#foreach ($column in $table.columns)
#if ($column.type == $STRING)
		#_soci_field_type($column) $column.name = "";
#elseif ($column.type == $DATETIME)
		std::tm $column.name;
#end
#end

		const char *_sqlstr = " select "
#foreach ($column in $table.columns)
#if ( $velocityHasNext == true )
			" $column.name, "
#else
			" $column.name "
#end
#end
			" from $table.name "
			" where 1 = 1 "
#foreach ($column in $index.columns)
			"   and $column.name = :$column.name "
#end
		;

		_sql << _sqlstr
#foreach ($column in $table.columns)
#if ($column.type == $STRING)
			, into($column.name)
#elseif ($column.type == $DATETIME)
			, into($column.name)
#else
			, into(entity->${column.name})
#end
#end
#foreach ($column in $index.columns)
			, use(i_$column.name)
#end
		;

#foreach ($column in $table.columns)
#if ($column.type == $STRING)
		strncpy( entity->${column.name}, ${column.name}.c_str(), #_c_field_size($column) );
#elseif ($column.type == $DATETIME)
		entity->${column.name} = (#_soci_field_type($column))mktime(&$column.name);
#end
#end

		return true;
	}

	bool #_dao_name($table)::update_by_$index.name ( #_c_struct_name($table) *entity )
	{
#foreach ($column in $table.columns)
#if ($column.type == $DATETIME)
        std::tm $column.name;
        localtime_r((time_t *)&entity->$column.name, &$column.name);
#else
		#_soci_field_type($column) $column.name = entity->$column.name;
#end
#end

		const char *_sqlstr = "update $table.name set "
#foreach ($column in $table.columns)
#if ($velocityHasNext == true)
			" $column.name = :$column.name, "
#else
			" $column.name = :$column.name "
#end
#end
			" where 1 = 1 "
#foreach ($column in $index.columns)
			" and $column.name = :$column.name "
#end
		;

		_sql << _sqlstr
#foreach ($column in $table.columns)
			, use($column.name)
#end
#foreach ($column in $index.columns)
			, use($column.name)
#end
		;

		return true;
	}

	bool #_dao_name($table)::delete_by_$index.name ( #_c_struct_name($table) *entity )
	{
#foreach ($column in $index.columns)
		#_soci_field_type($column) $column.name = entity->$column.name;
#end
		const char *_sqlstr =
			" delete from $table.name where 1 = 1 "
#foreach ($column in $index.columns)
			" and $column.name = :$column.name "
#end
		;
		_sql <<  _sqlstr
#foreach ($column in $index.columns)
    	, use($column.name)
#end
		;
		return true;
	}
#end

    size_t #_dao_name($table)::count()
	{
    	size_t _co = 0;
		const char *_sqlstr =
		" select count(*) from $table.name where 1 = 1 ";
		_sql << _sqlstr, into(_co);
		return _co;
	}
    // class #_dao_name($table) implements end.

#end
}
}
