#parse("common.vm")

#c_copyright()
/**
* @file
* all structs definition of $filename.
*
* NOTICE:
* This file is generated by tools.
* Please dont't modify this file.
*/
#ifndef ZT_SOCI_${upFileName.toUpperCase()}_CONVERSION_H
\#define ZT_SOCI_${upFileName.toUpperCase()}_CONVERSION_H 1

\#include "$entityHeaderFile"
\#include <soci.h>
\#include <string>
\#include <string.h>
\#include <ctime>
\#include <time.h>

namespace soci {
#foreach ($table in $tables)
template <>
struct type_conversion<#_c_struct_name($table)>
{
	typedef values base_type;
	static void from_base(values const &v, indicator /* ind */, #_c_struct_name($table) &entity )
	{
#foreach ($column in $table.columns)
#if ($column.type == $STRING)
    	strncpy( entity.${column.name},
			v.get<std::string>("${column.name}", "").c_str(),
			#_c_field_size($column) );
#elseif ($column.type == $DATETIME)
		std::tm dt_$column.name = v.get<std::tm>("${column.name}");
		entity.$column.name = (#_soci_field_type($column))mktime(&dt_$column.name);
#else
		entity.$column.name = v.get<#_c_field_type($column)>("$column.name");
#end
#end
	}

	static void to_base(const #_c_struct_name($table) &entity, values &v, indicator & ind)
	{
#foreach ($column in $table.columns)
#if ($column.type == $STRING)
		std::string i_$column.name = entity.$column.name;
		v.set("$column.name", i_$column.name, i_${column.name}.empty() ? i_null : i_ok );
#elseif ($column.type == $DATETIME)
		std::tm dt_$column.name;
		localtime_r((time_t *)&entity.$column.name, &dt_$column.name);
    	v.set("$column.name", dt_$column.name);
#else
		v.set("$column.name", entity.$column.name);
#end
#end
		ind = i_ok;
	}

};

#end
}

#endif /* ZT_SOCI_${upFileName}_CONVERSION_H */